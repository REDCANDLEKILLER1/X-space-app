<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>X-DYNAMIC // HUD v2.6</title>
    <style>
        :root {
            --neon-green: #39ff14;
            --dark-bg: #050505;
            --lime-fire: #ccff00;
            --alert-red: #ff003c;
            --border-glow: 0 0 10px rgba(57, 255, 20, 0.5);
        }

        body {
            background-color: var(--dark-bg);
            color: var(--neon-green);
            font-family: 'Courier New', Courier, monospace;
            margin: 0; padding: 20px;
            display: flex; flex-direction: column; align-items: center;
        }

        body::before {
            content: " "; display: block; position: fixed;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 100; background-size: 100% 2px, 3px 100%; pointer-events: none;
        }

        .header {
            width: 100%; max-width: 600px;
            border: 1px solid var(--neon-green); padding: 10px;
            text-align: center; box-shadow: var(--border-glow); margin-bottom: 20px;
        }

        .hud-container { width: 100%; max-width: 600px; display: grid; gap: 15px; }

        .module {
            border: 1px solid var(--neon-green); padding: 15px;
            background: rgba(0, 0, 0, 0.9); position: relative;
        }

        .module-title {
            position: absolute; top: -10px; left: 10px;
            background: var(--dark-bg); padding: 0 5px;
            font-size: 0.8rem; text-transform: uppercase;
        }

        .meter-container { height: 12px; background: #111; border: 1px solid #333; margin: 10px 0; overflow: hidden; }
        .meter-fill { height: 100%; width: 0%; background: var(--neon-green); transition: width 0.05s linear; }

        .controls { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 10px; }

        button {
            background: transparent; border: 1px solid var(--neon-green);
            color: var(--neon-green); padding: 10px; cursor: pointer;
            text-transform: uppercase; font-weight: bold; flex-grow: 1; font-size: 0.75rem;
        }

        button.active { background: var(--neon-green); color: var(--dark-bg); }
        button.muted { border-color: var(--alert-red); color: var(--alert-red); }
        button.live { background: var(--alert-red); color: white; border-color: var(--alert-red); box-shadow: 0 0 10px var(--alert-red); }

        input[type="range"] { width: 100%; accent-color: var(--neon-green); margin: 5px 0; }

        .transport-bar { background: #111; padding: 10px; margin-top: 10px; border: 1px dashed var(--neon-green); }
        .track-info { font-size: 0.8rem; margin-bottom: 5px; color: var(--lime-fire); height: 1.2rem; overflow: hidden; }

        .track-slot {
            display: flex; align-items: center; justify-content: space-between;
            margin: 5px 0; padding: 8px; border: 1px solid #222; font-size: 0.75rem;
            background: rgba(20,20,20,0.5);
        }

        .time-display { display: flex; justify-content: space-between; font-size: 0.7rem; margin-top: 2px; }
        .hidden { display: none; }
    </style>
</head>
<body>

    <div class="header">
        <h1>X-DYNAMIC // COMMAND_CENTER</h1>
        <div id="status-display">ENGINE: OFFLINE</div>
    </div>

    <div class="hud-container">
        <!-- MIC MODULE -->
        <div class="module">
            <div class="module-title">Voice Link</div>
            <div class="meter-container"><div id="mic-meter" class="meter-fill"></div></div>
            <div class="controls">
                <button id="start-btn">Init Engine</button>
                <button id="mic-mute-btn" class="muted">MIC: MUTED</button>
                <button id="duck-toggle">Auto-Duck: OFF</button>
            </div>
            <input type="range" id="mic-gain" min="0" max="4" step="0.1" value="1">
        </div>

        <!-- MASTER PLAYER MODULE -->
        <div class="module">
            <div class="module-title">Media Transport</div>
            <div class="meter-container"><div id="music-meter" class="meter-fill"></div></div>
            
            <div class="transport-bar">
                <div id="current-track-name" class="track-info">NO TRACK LOADED</div>
                <input type="range" id="seek-bar" value="0" min="0" max="100" step="0.1">
                <div class="time-display">
                    <span id="time-curr">0:00</span>
                    <span id="time-total">0:00</span>
                </div>
                
                <div class="controls">
                    <button id="prev-btn">Prev</button>
                    <button id="play-pause-btn">Play</button>
                    <button id="next-btn">Next</button>
                    <button id="loop-btn">Loop: OFF</button>
                </div>
            </div>

            <div class="controls">
                <button id="load-trigger-btn">Load Audio Tracks (+)</button>
            </div>
            <input type="file" id="file-input" class="hidden" accept="audio/*" multiple>
            
            <div id="track-list" style="margin-top:10px; max-height:150px; overflow-y:auto; border-top:1px solid #333;"></div>
            
            <div style="margin-top:10px">
                <label style="font-size:0.7rem">Music Volume</label>
                <input type="range" id="music-vol" min="0" max="1" step="0.05" value="0.5">
            </div>
        </div>

        <!-- MASTER BUS -->
        <div class="module" style="border-color: var(--lime-fire);">
            <div class="module-title" style="color: var(--lime-fire);">Master Out Feed</div>
            <div class="meter-container"><div id="master-meter" class="meter-fill" style="background: var(--lime-fire);"></div></div>
        </div>
    </div>

    <script>
        let audioCtx, micNode, micGainNode, musicGainNode, masterDest;
        let analyserMic, analyserMusic, analyserMaster;
        let isMicMuted = true, isDucking = false, isLooping = false;
        
        let playlist = [];
        let currentIndex = -1;
        const audio = new Audio();
        audio.crossOrigin = "anonymous";
        let audioSource = null;

        const startBtn = document.getElementById('start-btn');
        const micMuteBtn = document.getElementById('mic-mute-btn');
        const duckToggle = document.getElementById('duck-toggle');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const loopBtn = document.getElementById('loop-btn');
        const seekBar = document.getElementById('seek-bar');
        const trackNameDisplay = document.getElementById('current-track-name');
        const loadBtn = document.getElementById('load-trigger-btn');
        const fileInput = document.getElementById('file-input');

        async function init() {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } 
                });
                
                micNode = audioCtx.createMediaStreamSource(stream);
                micGainNode = audioCtx.createGain();
                musicGainNode = audioCtx.createGain();
                masterDest = audioCtx.createMediaStreamDestination();
                
                analyserMic = audioCtx.createAnalyser();
                analyserMusic = audioCtx.createAnalyser();
                analyserMaster = audioCtx.createAnalyser();

                micNode.connect(analyserMic);
                micNode.connect(micGainNode);
                micGainNode.connect(masterDest);
                micGainNode.connect(analyserMaster);
                micGainNode.gain.value = 0;

                musicGainNode.connect(masterDest);
                musicGainNode.connect(analyserMusic);
                musicGainNode.connect(analyserMaster);

                audioSource = audioCtx.createMediaElementSource(audio);
                audioSource.connect(musicGainNode);

                startBtn.classList.add('active');
                startBtn.innerText = "ONLINE";
                document.getElementById('status-display').innerText = "ENGINE: ACTIVE";
                
                render();
            } catch (e) { alert("Engine Init Failed. Ensure Mic Access."); }
        }

        function render() {
            const update = () => {
                drawMeter(analyserMic, 'mic-meter');
                drawMeter(analyserMusic, 'music-meter');
                drawMeter(analyserMaster, 'master-meter');
                
                if (!audio.paused && audio.duration) {
                    seekBar.value = (audio.currentTime / audio.duration) * 100;
                    document.getElementById('time-curr').innerText = formatTime(audio.currentTime);
                    document.getElementById('time-total').innerText = formatTime(audio.duration);
                }

                if (isDucking && !isMicMuted && analyserMic) {
                    const data = new Uint8Array(analyserMic.frequencyBinCount);
                    analyserMic.getByteFrequencyData(data);
                    const vol = data.reduce((a, b) => a + b) / data.length;
                    const targetGain = vol > 25 ? 0.1 : document.getElementById('music-vol').value;
                    musicGainNode.gain.setTargetAtTime(targetGain, audioCtx.currentTime, 0.2);
                }
                requestAnimationFrame(update);
            };
            update();
        }

        function formatTime(secs) {
            if (isNaN(secs)) return "0:00";
            let m = Math.floor(secs / 60);
            let s = Math.floor(secs % 60);
            return `${m}:${s < 10 ? '0' : ''}${s}`;
        }

        function drawMeter(analyser, id) {
            if (!analyser) return;
            const data = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(data);
            const avg = data.reduce((a, b) => a + b) / data.length;
            document.getElementById(id).style.width = Math.min(avg * 2.5, 100) + "%";
        }

        // Exposed globally for the HTML buttons
        window.loadTrack = function(index) {
            if (index < 0 || index >= playlist.length) return;
            if (!audioCtx) { alert("Init Engine First!"); return; }
            
            currentIndex = index;
            audio.src = playlist[currentIndex].url;
            audio.load(); // Forces Android browsers to recognize the new source
            trackNameDisplay.innerText = playlist[currentIndex].name;
            audio.play().catch(e => console.log("Play interrupted"));
            playPauseBtn.innerText = "PAUSE";
            updatePlaylistUI();
        };

        playPauseBtn.onclick = () => {
            if (!audio.src) return;
            if (audio.paused) { audio.play(); playPauseBtn.innerText = "PAUSE"; }
            else { audio.pause(); playPauseBtn.innerText = "PLAY"; }
        };

        document.getElementById('next-btn').onclick = () => {
            if (playlist.length === 0) return;
            let next = (currentIndex + 1) % playlist.length;
            window.loadTrack(next);
        };

        document.getElementById('prev-btn').onclick = () => {
            if (playlist.length === 0) return;
            let prev = (currentIndex - 1 + playlist.length) % playlist.length;
            window.loadTrack(prev);
        };

        loopBtn.onclick = () => {
            isLooping = !isLooping;
            audio.loop = isLooping;
            loopBtn.innerText = isLooping ? "Loop: ON" : "Loop: OFF";
            loopBtn.classList.toggle('active');
        };

        seekBar.oninput = () => {
            if (audio.duration) {
                audio.currentTime = (seekBar.value / 100) * audio.duration;
            }
        };

        audio.onended = () => {
            if (!isLooping) document.getElementById('next-btn').click();
        };

        loadBtn.onclick = () => fileInput.click();

        fileInput.onchange = (e) => {
            if (e.target.files.length === 0) return;
            
            const startIdx = playlist.length;
            for (let f of e.target.files) {
                playlist.push({ name: f.name, url: URL.createObjectURL(f) });
            }
            updatePlaylistUI();
            
            // If nothing is playing, load the first item of the new batch
            if (currentIndex === -1) {
                window.loadTrack(startIdx);
            }
        };

        function updatePlaylistUI() {
            const list = document.getElementById('track-list');
            list.innerHTML = "";
            playlist.forEach((track, i) => {
                const div = document.createElement('div');
                div.className = 'track-slot';
                if(i === currentIndex) div.style.borderColor = "var(--lime-fire)";
                div.innerHTML = `<span>${track.name.substring(0,25)}</span><button onclick="window.loadTrack(${i})">LOAD</button>`;
                list.appendChild(div);
            });
        }

        startBtn.onclick = async () => {
            if (audioCtx) {
                if (audioCtx.state === 'suspended') await audioCtx.resume();
            } else {
                await init();
            }
        };

        micMuteBtn.onclick = () => {
            if (!micGainNode) return;
            isMicMuted = !isMicMuted;
            micGainNode.gain.setTargetAtTime(isMicMuted ? 0 : document.getElementById('mic-gain').value, audioCtx.currentTime, 0.05);
            micMuteBtn.innerText = isMicMuted ? "MIC: MUTED" : "MIC: LIVE";
            micMuteBtn.className = isMicMuted ? "muted" : "live";
        };

        document.getElementById('mic-gain').oninput = (e) => { 
            if(!isMicMuted && micGainNode) micGainNode.gain.value = e.target.value; 
        };
        document.getElementById('music-vol').oninput = (e) => { 
            if(musicGainNode) musicGainNode.gain.value = e.target.value; 
        };
        duckToggle.onclick = () => { 
            isDucking = !isDucking; 
            duckToggle.classList.toggle('active'); 
            duckToggle.innerText = isDucking ? "Auto-Duck: ON" : "Auto-Duck: OFF"; 
        };
    </script>
</body>
</html>